"""Generate `src/molop/io/_typing_catalog.pyi`.

This script scans MolOP model modules (without importing them) and emits a stub
file that lists concrete Disk model classes as unions.

Rationale
- We want rich IDE type hints for batch containers without hardcoding per-format
  lists inside core runtime modules.
- Type checkers (pyright/mypy) do not execute dynamic discovery logic during
  analysis, so a generated static stub is the reliable approach.

Usage
  uv run python scripts/generate_io_typing_catalog.py
"""

from __future__ import annotations

import argparse
import ast
import difflib
from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class _Export:
    module: str
    name: str


def _src_root(repo_root: Path) -> Path:
    return repo_root / "src"


def _module_name(src_root: Path, py_file: Path) -> str:
    rel = py_file.relative_to(src_root)
    return ".".join(rel.with_suffix("").parts)


def _iter_py_files(dir_path: Path) -> list[Path]:
    return sorted(
        [p for p in dir_path.glob("*.py") if p.is_file() and p.name != "__init__.py"],
        key=lambda p: p.as_posix(),
    )


def _discover_exports(
    src_root: Path, search_dirs: list[Path]
) -> tuple[list[_Export], list[_Export]]:
    file_exports: list[_Export] = []
    frame_exports: list[_Export] = []

    for d in search_dirs:
        for py in _iter_py_files(d):
            mod = _module_name(src_root, py)
            tree = ast.parse(py.read_text(encoding="utf-8"), filename=str(py))
            for node in tree.body:
                if not isinstance(node, ast.ClassDef):
                    continue
                name = node.name
                if name.endswith("FileDisk"):
                    file_exports.append(_Export(module=mod, name=name))
                if name.endswith("FileFrameDisk"):
                    frame_exports.append(_Export(module=mod, name=name))

    # Deterministic order. Prefer module-first sorting to align with import
    # sorting used by formatters/linters.
    file_exports = sorted(file_exports, key=lambda e: (e.module.lower(), e.module, e.name))
    frame_exports = sorted(frame_exports, key=lambda e: (e.module.lower(), e.module, e.name))
    return file_exports, frame_exports


def _render_typealias(name: str, items: list[str], *, max_len: int = 100) -> list[str]:
    """Render a TypeAlias, wrapping long unions.

    The wrapping style is chosen to be stable under common formatters.
    """

    if not items:
        return [f"{name}: TypeAlias = object"]

    expr = " | ".join(items)
    line = f"{name}: TypeAlias = {expr}"
    if len(line) <= max_len:
        return [line]

    return [
        f"{name}: TypeAlias = (",
        f"    {expr}",
        ")",
    ]


def _render_stub(file_exports: list[_Export], frame_exports: list[_Export]) -> str:
    lines: list[str] = []
    lines.append(
        "\n".join(
            [
                '"""Static typing catalog for MolOP IO (generated).',
                "",
                "DO NOT EDIT MANUALLY.",
                "Generated by: scripts/generate_io_typing_catalog.py",
                '"""',
            ]
        )
    )
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from typing import TypeAlias")
    lines.append("")

    # Imports (single, module-sorted block)
    imports = sorted(
        file_exports + frame_exports, key=lambda e: (e.module.lower(), e.module, e.name)
    )
    for e in imports:
        lines.append(f"from {e.module} import {e.name}")
    lines.append("")

    # Unions (name-sorted for readability)
    file_names = sorted({e.name for e in file_exports})
    frame_names = sorted({e.name for e in frame_exports})

    lines.extend(_render_typealias("FileDiskObj", file_names))
    lines.extend(_render_typealias("FrameDiskObj", frame_names))

    lines.append("")
    return "\n".join(lines)


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--check",
        action="store_true",
        help="Do not write; exit non-zero if stub would change.",
    )
    parser.add_argument(
        "--output",
        default="src/molop/io/_typing_catalog.pyi",
        help="Output stub path (default: src/molop/io/_typing_catalog.pyi)",
    )
    args = parser.parse_args(argv)

    repo_root = Path(__file__).resolve().parents[1]
    src_root = _src_root(repo_root)

    search_dirs = [
        # File models
        src_root / "molop" / "io" / "logic" / "coords_models",
        src_root / "molop" / "io" / "logic" / "qminput_models",
        src_root / "molop" / "io" / "logic" / "QM_models",
        # Frame models
        src_root / "molop" / "io" / "logic" / "coords_frame_models",
        src_root / "molop" / "io" / "logic" / "qminput_frame_models",
        src_root / "molop" / "io" / "logic" / "QM_frame_models",
    ]

    file_exports, frame_exports = _discover_exports(src_root, search_dirs)
    out = _render_stub(file_exports, frame_exports)

    import subprocess

    res = subprocess.run(
        ["uv", "run", "ruff", "format", "-", "--stdin-filename", "stub.pyi"],
        input=out,
        text=True,
        capture_output=True,
    )
    if res.returncode == 0:
        out = res.stdout

    out_path = (repo_root / args.output).resolve()

    if args.check:
        existing = out_path.read_text(encoding="utf-8") if out_path.exists() else ""
        if existing == out:
            print(f"OK: {out_path} is up to date")
            return 0
        diff = "\n".join(
            difflib.unified_diff(
                existing.splitlines(),
                out.splitlines(),
                fromfile=str(out_path),
                tofile="(generated)",
                lineterm="",
            )
        )
        print(diff)
        print(
            f"ERROR: {out_path} is out of date. Run: uv run python scripts/generate_io_typing_catalog.py"
        )
        return 1

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(out, encoding="utf-8")
    print(f"Wrote {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
